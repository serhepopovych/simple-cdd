#!/bin/bash

[ -z "${__distro_postinst__-}" ] || return 0
__distro_postinst__=1

## Global config

# Initial user account that can be used by automation setup services.
user='setup'

## Common helper routines

true()  {   :; }
false() { ! :; }

## Boot command line parameters handling helpers

_cmdline_file='/proc/cmdline'
cmdline_file="${cmdline_file:-${_cmdline_file}}"

# Usage: cmdline_get_console [<file>]
cmdline_get_console()
{
    local func="${FUNCNAME:-cmdline_get_console}"

    local file="${1:-$cmdline_file}"

    # Based on grub-installer udeb code.

    eval set -- $(cat "$file")

    local serial=

    # Get the last 'console=' entry (if none, the whole string is returned)
    while [ $# -gt 0 ]; do
        case "$1" in
            console=ttyS*|console=hvc*|console=com*)
                serial="$1"
                ;;
        esac
        shift
    done

    if [ -n "$serial" ]; then
        echo "$serial"
    fi
}

## Grub helpers

# Usage: grub_update ...
grub_update()
{
    if type update-grub2 >/dev/null 2>&1; then
        update-grub2
    elif type update-grub >/dev/null 2>&1; then
        update-grub
    else
        f="$(readlink '/etc/grub2.cfg' 2>/dev/null)" &&
            [ -n "$f" ] ||
        f='/boot/grub2/grub.cfg'

        grub2-mkconfig -o "$f"
    fi
}

# Usage: grub_serial_console <console=...>
grub_serial_console()
{
    local func="${FUNCNAME:-grub_serial_console}"

    local serconsole="${1:?missing 1st arg to ${func}() <console=...>}"
    shift

    local unit=''

    set -- $(IFS=',' && echo $serconsole)
    if [ $# -gt 2 ] || [ -n "${1##console=*}" ]; then
        : "${unit:?${func}: not in console=device[,...] format}"
    fi

    local unit="${1##console=*[^0-9]}"
    if [ -n "${unit#*[^0-9]*}" ]; then
        : "${unit:?${func}: no unit number in $1}"
    fi

    local speed='' parity='n' word='8'
    if [ -n "${2-}" ]; then
        speed="${2%%[^0-9]*}"

        parity="${2#$speed}"
        word="$parity"

        parity="${parity%%[0-9]*}"
        word="${word#$parity}"
        word="${word%%[^0-9]*}"
    fi
    speed="--speed=${speed:-115200}"
    case "$parity" in
        n) parity=' --parity=no'   ;;
        e) parity=' --parity=even' ;;
        o) parity=' --parity=odd'  ;;
        *) parity=''               ;;
    esac
    [ -z "$word" ] || word=" --word=$word"

    echo "serial --unit=$unit $speed$word$parity --stop=1"
}

## Package manager helpers

# Usage: pkg_is_installed <pkg_name>
pkg_is_installed()
{
    local func="${FUNCNAME:-pkg_is_installed}"

    local pkg_name="${1:?missing 1st arg to ${func}() <pkg_name>}"

    if [ -z "${pkg_is_installed__cmd-}" ]; then
        if type rpm >/dev/null 2>&1; then
            pkg_is_installed__cmd='rpm -qi'
        elif type dpkg >/dev/null 2>&1; then
            pkg_is_installed__cmd='dpkg -s'
        else
            pkg_is_installed__cmd='false'
        fi
    fi

    $pkg_is_installed__cmd "$pkg_name" >/dev/null 2>&1 || return
}

## Shell-style file handling helpers

if by="${0##*/}" && [ -n "${by##*bash*}" ]; then
    by="by $by"
else
    by='by distro.postinst'
fi

# Usage: shell_var_replace <file> <opt> <val>
shell_var_replace()
{
    local func="${FUNCNAME:-shell_var_replace}"

    local file="${1:?missing 1st arg to ${func}() <file>}"
    local opt="${2:?missing 2d arg to ${func}() <opt>}"
    local val="${3:?missing 3rd arg to ${func}() <val>}"

    if [ -f "$file" ]; then
        local o="$opt"
        opt="${opt#\#}"

        sed -i "$file" \
            -e "s/^\s*$opt=/#commented $by#&/" \
            -e "\$a\\

#replaced $by#\\
$o=\"$val\"" \
            #
    fi
}

# Usage: shell_var_extend() <file> <opt> <val>
shell_var_extend()
{
    local func="${FUNCNAME:-shell_var_extend}"

    local file="${1:?missing 1st arg to ${func}() <file>}"
    local opt="${2:?missing 2d arg to ${func}() <opt>}"
    local val="${3:?missing 3rd arg to ${func}() <val>}"

    if [ -f "$file" ]; then
        local o="$opt"
        opt="${opt#\#}"

        echo >>"$file"
        echo >>"$file" "#extended $by#"
        echo >>"$file" "$o=\"\${$opt:+\$$opt }$val\""
    fi
}

## Init manager helpers

systemd_lib_unit='/lib/systemd/system'
systemd_etc_unit='/etc/systemd/system'

# Usage: systemd_unit_cleanup <unit1> <unit2> ...
systemd_unit_cleanup()
{
    local func="${FUNCNAME:-systemd_unit_cleanup}"

    local u="${systemd_unit:-$systemd_lib_unit}"
    local p="${systemd_root-}/${u#/}"

    # Supported systemd.unit(5) directives vary from version to version.
    #
    # If local package (e.g. openvpn) being installed provides unit
    # file targeted more recent systemd(1) console is filled by systemd(1)
    # with warnings about unsupported directives.
    #
    # This helper intended to cleanup specified units to keep them only
    # with most common directives. Tested on Debian GNU/Linu 7.x (wheezy)
    # and local packages (e.g. openvpn) from 10.x (buster).

    local f
    for f in "$@"; do
        f="$p/$f"

        if [ -f "$f" ]; then
            sed -i "$f" \
                -e '/^Documentation=/           s/^/#/' \
                -e '/^Protect\(System\|Home\)=/ s/^/#/' \
                -e '/^KillMode=/                s/^/#/' \
                -e '/^Delegate=/                s/^/#/' \
                -e '/^PartOf=/                  s/^/#/' \
                -e '/^ReloadPropagatedFrom=/    s/^/#/' \
                #

            grep -q '^Type=oneshot' "$f" || continue

            sed -i "$f" \
                -e '/^ExecReload=/d' \
                #
        fi
    done
}

# Usage: systemd_unit_get <section> <attribute> <unit1> <unit2> ...
systemd_unit_get()
{
    local func="${FUNCNAME:-systemd_unit_get}"

    local u="${systemd_unit:-$systemd_lib_unit}"
    local p="${systemd_root-}/${u#/}"

    local section="${1:?missing 1st arg to ${func}() <section>}"
    local attribute="${2:?missing 2d arg to ${func}() <attribute>}"
    shift 2

    local f t=' '
    for f in "$@"; do
        [ -n "${t##* $f *}" ] || continue

        t="$t$f "

        f="$p/$f"
        if [ -f "$f" ]; then
            echo "$f"
        fi
    done | xargs sed -n -e "/\\[$section\\]/,/\\[/ s/^$attribute=//p"
}

# Usage: systemd_unit_list <section> <attribute> <unit1> <unit2> ...
systemd_unit_list()
{
    local func="${FUNCNAME:-systemd_unit_list}"

    local section="${1:?missing 1st arg to ${func}() <section>}"
    local attribute="${2:?missing 2d arg to ${func}() <attribute>}"
    shift 2

    local e="${systemd_root-}/${systemd_etc_unit#/}"
    local l="${systemd_root-}/${systemd_lib_unit#/}"

    local f ifs

    local tt=' '
    local et=' ' et_dir="$systemd_etc_unit"
    local lt=' ' lt_dir="$systemd_lib_unit"

    for f in "$@"; do
        f="${f##*/}"

        [ -n "${tt##* $f *}" ] || continue

          if [ -f "$e/$f" ]; then
            et="$et$f "
        elif [ -f "$l/$f" ]; then
            lt="$lt$f "
        else
            continue
        fi

        tt="$tt$f "
    done

    for f in 'et' 'lt'; do
        for f in \
            $(
                eval "
                    export systemd_unit=\"\$${f}_dir\"
                    systemd_unit_get \"\$section\" \"\$attribute\" \$${f}
                "
             )
        do
            [ -z "${tt##* $f *}" ] || tt="$tt$f "
        done
    done

    echo $tt
}

# Usage: systemd_unit_enable <unit1> <unit2> ...
systemd_unit_enable()
{
    local func="${FUNCNAME:-systemd_unit_enable}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${systemd_root-}/${u#/}"
    u="$systemd_lib_unit"

    local rc=0

    local f t
    for f in $(systemd_unit_list 'Install' 'Also' "$@"); do
        for t in $(systemd_unit_get 'Install' 'WantedBy' "$f"); do
            t="$p/$t.wants"

            install -d "$t" && ln -sf "$u/$f" "$t/$f" || rc=$((rc + $?))
        done
    done

    return $rc
}

# Usage: systemd_unit_disable <unit1> <unit2> ...
systemd_unit_disable()
{
    local func="${FUNCNAME:-systemd_unit_disable}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${systemd_root-}/${u#/}"

    local rc=0

    local f
    for f in $(systemd_unit_list 'Install' 'Also' "$@"); do
        for f in "$p"/*.target.wants/$f; do
            [ ! -L "$f" ] || rm -f "$f" || rc=$((rc + $?))
        done
    done

    return $rc
}

# Usage: service_enable <name>
service_enable()
{
    local func="${FUNCNAME:-service_enable}"

    local f="${1:?missing 1st arg to ${func}() <name>}"

    local rc=0

    f="${f%.service}"
    chroot "${root:-/}" update-rc.d "$f" defaults &&
    chroot "${root:-/}" update-rc.d "$f" enable || rc=$?

    local systemd_root="${root-}"

    f="$f.service"
    systemd_unit_cleanup "$f"
    systemd_unit_enable  "$f" || return $rc
}

# Usage: service_disable <name>
service_disable()
{
    local func="${FUNCNAME:-service_disable}"

    local f="${1:?missing 1st arg to ${func}() <name>}"

    local rc=0

    f="${f%.service}"
    chroot "${root:-/}" update-rc.d "$f" disable || rc=$?

    local systemd_root="${root-}"

    f="$f.service"
    systemd_unit_cleanup "$f"
    systemd_unit_disable "$f" || return $rc
}

## Initial setup based on distro

eval $(
    # Source in subshell to not pollute environment

    release_file='/etc/os-release'

    if [ -f "$release_file" ] && . "$release_file" >/dev/null 2>&1; then
        distro="$ID"
        release="$VERSION_ID"
        codename="$VERSION_CODENAME"
        [ -n "$codename" ] ||
            codename="$(echo "$PRETTY_NAME" | sed -n -e 's/^.*(\(\w\+\)).*$/\1/p')"
    elif type lsb_release >/dev/null 2>&1; then
        distro="$(lsb_release -s -i)"
        release="$(lsb_release -s -r)"
        codename="$(lsb_release -s -c)"
    else
        # old or unsupported distro
        distro=''
        release=''
        codename=''
    fi

    distro="$(echo "$distro" | tr '[:upper:]' '[:lower:]')"
    [ -n "$distro" ] || exit

    release="${release%%.*}"
    [ "$release" -gt 0 ] 2>/dev/null || exit

    if [ "$distro" = 'centos' ]; then
        last_supported_release=7
    elif [ "$distro" = 'debian' ]; then
        last_supported_release=9
    else
        # unsupported distro
        exit 1
    fi

    [ $release -ge $last_supported_release ] &&
        new_distro=true || new_distro=false

    if [ "$distro" = 'debian' ]; then
        if $new_distro; then
            apt_url='http://deb.debian.org'
        else
            apt_url='http://archive.debian.org'
        fi
    else
        apt_url=''
    fi

    printf 'distro=%s release=%s codename=%s new_distro=%s apt_url=%s\n' \
        "$distro" "$release" "$codename" "$new_distro" "$apt_url"
)

[ -n "$distro" ] || exit

## Exit/return successfuly

:

#!/bin/bash

[ -z "${__distro_postinst__-}" ] || return 0
__distro_postinst__=1

## Global config

# Initial user account that can be used by automation setup services.
user='setup'

## Common helper routines

true()  {   :; }
false() { ! :; }

# Usage: unique [<sep>] <val1>...
unique()
{
    local func="${FUNCNAME:-unique}"

    local sep="${1:-|}"
    shift
    local r

    r="$sep"
    while [ $# -gt 0 ]; do
        [ -z "${r##*$sep$1$sep*}" ] ||
            r="$r$1$sep"
        shift
    done

    printf '%s\n' "$r"
}

# Usage: intersect__ {<sep>|''} {<set1>|''} [<set2>|'']
intersect__()
{
    local func="${func:-${FUNCNAME:-intersect__}}"

    : ${__intersect_test_op__:?${func}() must not be called directly}

    local sep="${1:-|}"

    local set1="${2:-$sep}"
    if [ -n "${set1##$sep*}" -o -n "${set1%%*$sep}" ]; then
        set1=''
        : ${set1:?${func}() set1 does not match [$sep[[<val1>$sep..]$sep]]}
    fi

    local r="$sep"

    if [ -n "${3-}" ]; then
        local set2="$3"

        if [ -n "${set2##$sep*$sep*}" -o -n "${set2%%*$sep*$sep}" ]; then
            set2=''
            : ${set2:?${func}() set2 does not match $sep[[<val1>$sep..]$sep}
        fi

        local ifs="$IFS"
        IFS="$sep" && set -- ${set2#$sep}
        IFS="$ifs"

        local t
        while [ $# -gt 0 ]; do
            t="*$sep$1$sep*"
            # unique() and not in set1
            [ -z "${r##$t}" -o ${__intersect_test_op__} "${set1##$t}" ] ||
                r="$r$1$sep"
            shift
        done
    fi

    printf '%s\n' "$r"
}

# Usage: intersect {<sep>|''} {<set1>|''} [<set2>|'']
intersect()
{
    local func="${FUNCNAME:-intersect}"
    local __intersect_test_op__='-n'
    intersect__ "$@" || return
}

# Usage: n_intersect {<sep>|''} {<set1>|''} [<set2>|'']
n_intersect()
{
    local func="${FUNCNAME:-n_intersect}"
    local __intersect_test_op__='-z'
    intersect__ "$@" || return
}

## Boot command line parameters handling helpers

readonly _cmdline_file='/proc/cmdline'
cmdline_file="${cmdline_file:-${_cmdline_file}}"

# Usage: cmdline_get_console [<file>] [<inuser>|<ingrub>]
cmdline_get_console()
{
    local func="${FUNCNAME:-cmdline_get_console}"

    local file="${1:-$cmdline_file}"
    local inuser="${2+x}"

    # Based on grub-installer udeb code.

    set -- $(cat "$file")

    local serial=''

    # Get the last 'console=' entry (if none, the whole string is returned)
    while [ $# -gt 0 ]; do
        case "$1" in
            '--'|'---')
                inuser='x'
                ;;
            console=ttyS*|console=hvc*|console=com*)
                if [ -n "$inuser" ]; then
                    serial="$1"
                fi
                ;;
        esac
        shift
    done

    if [ -n "$serial" ]; then
        printf '%s\n' "$serial"
    else
        return
    fi
}

## Grub helpers

# Usage: grub_update ...
grub_update()
{
    local rc=0

    if type update-grub2 >/dev/null 2>&1; then
        update-grub2 "$@" || rc=$?
    elif type update-grub >/dev/null 2>&1; then
        update-grub "$@" || rc=$?
    else
        if type grub2-mkconfig >/dev/null 2>&1; then
            grub2_mkconfig() { grub2-mkconfig "$@" || return; }
        elif type grub-mkconfig >/dev/null 2>&1; then
            grub2_mkconfig() { grub-mkconfig "$@" || return; }
        else
            return 1
        fi

        local f t
        for f in \
            '/etc/grub2.cfg' \
            '/etc/grub2-efi.cfg' \
            '/boot/grub2/grub.cfg' \
            '/boot/grub/grub.cfg' \
            '' \
            #
        do
            if [ -z "$f" ]; then
                rc=$((rc + 1))
                break
            fi
            if [ -L "$f" ]; then
                if f="$(readlink -f "$f" 2>/dev/null)" && [ -n "$f" ]; then
                    :
                else
                    rc=$((rc + $?))
                    continue
                fi
            fi
            t="${f%/*}"
            if [ -f "$f" -o -d "$t/locale" -o -d "$t/fonts" ]; then
                if grub2_mkconfig -o "$f" "$@" && rc=0; then
                    break
                else
                    rc=$((rc + $?))
                fi
            fi
        done

        unset -f grub2_mkconfig
    fi

    return $rc
}

# Usage: grub_serial_console <console=...>
grub_serial_console()
{
    local func="${FUNCNAME:-grub_serial_console}"

    local serconsole="${1:?missing 1st arg to ${func}() <console=...>}"
    shift

    local unit=''

    set -- $(IFS=',' && echo $serconsole)
    if [ $# -gt 2 ] || [ -n "${1##console=*}" ]; then
        : "${unit:?${func}: not in console=device[,...] format}"
    fi

    local unit="${1##console=*[!0-9]}"
    if [ -z "$unit" ]; then
        : "${unit:?${func}: no unit number in $1}"
    fi
    if [ -d '/sys/firmware/efi' ]; then
        # replace <u> with efi<u> on EFI systems for --unit= to fix artifacts
        unit="efi$unit"
    fi

    local speed='' parity='n' word='8'
    if [ -n "${2-}" ]; then
        speed="${2%%[!0-9]*}"

        parity="${2#$speed}"
        word="$parity"

        parity="${parity%%[0-9]*}"
        word="${word#$parity}"
        word="${word%%[!0-9]*}"
    fi
    speed="--speed=${speed:-115200}"
    case "$parity" in
        n) parity=' --parity=no'   ;;
        e) parity=' --parity=even' ;;
        o) parity=' --parity=odd'  ;;
        *) parity=''               ;;
    esac
    [ -z "$word" ] || word=" --word=$word"

    echo "serial --unit=$unit $speed$word$parity --stop=1"
}

# Usage: grub__config <name> <var> <val>...
grub__config()
{
    local func="${func:-${FUNCNAME:-grub__config}}"

    local name="${1-}"

    if name="${name##simple-cdd-}" && [ -n "$name" ] &&
       name="simple-cdd-$name" && [ -n "${name##${__grub_config_name__}}" ]
    then
        __grub_config_name__=''
    else
        name="${__grub_config_name__:?missing 1st arg to ${func}() <name>}"
    fi

    local var="${2:?missing 2d arg to ${func}() <var>}"

    shift 2

    local ifs="$IFS" t

    IFS='|' && t="|$*|"
    IFS="$ifs"

    t="$(
        n_intersect '|' "$(grub_config_get_val "$var" '|')" "$t"
    )"

    IFS='|' && set -- ${t#|}
    IFS="$ifs"

    if t=" $* " && [ -n "${t##*[!$IFS]*}" ]; then
        if [ -n "${__grub_config_append__-}" ]; then
            # Nothing to configure: all values already present or "$*" empty
            return 0
        fi
        set --
    fi

    t="/etc/default/grub.d/$name.cfg"

    # Add configuration
    [ -d "${t%/*.cfg}/" ] || t="${t%.d/*.cfg}"

    {
        # Add header to annotate configuration block, if needed
        if [ -z "${__grub_config_name__}" -a -n "${t%%*.cfg}" ]; then
            echo
            echo "### $name"
        fi

        printf '%s="%s%s"\n' \
            "$var" \
            "${__grub_config_append__:+\${$var:+\$$var \}}" \
            "$*" \
            #
    } >>"$t"

    __grub_config_name__="$name"
}

# Usage: grub_config_set <name> <var> <val>...
grub_config_set()
{
    local func="${FUNCNAME:-grub_config_set}"
    local __grub_config_append__=''
    grub__config "$@"
}

# Usage: grub_config_add <name> <var> <val>...
grub_config_add()
{
    local func="${FUNCNAME:-grub_config_add}"
    local __grub_config_append__='1'
    grub__config "$@"
}

# Usage: grub_config_get <var>...
grub_config_get()
{
    local func="${FUNCNAME:-grub_config_get}"

    local t rc=1

    if [ $# -le 0 ]; then
        set --
        : "${1:?missing args to ${func}() [<var>...]}"
    fi
    if t=" $* " && [ -n "${t##*[!$IFS]*}" ]; then
        set --
        : "${1:?empty args to ${func}() [<var>...]}"
    fi

    # This evaluates only GRUB_*=... and rc={0|1} variables assignment
    eval $(
        env -i /bin/sh -c '
            # Try to close all file descriptors to avoid escape to
            # eval $() or others sensitive file descriptors of
            # calling shell.
            for t in /proc/$$/fd/*; do
                if [ -e "$t" ] &&
                   t="${t##*/}" && [ -n "${t##*[!0-9]*}" ]
                then
                    case "$t" in
                        0|1|2)
                            ;;
                        *)
                            eval "exec $t<&-"
                            ;;
                    esac
                fi
            done

            # Source in subshell to not pollute environment

            t='\''/etc/default/grub'\''
            rc=1

            if [ -r "$t" ] && . "$t" >/dev/null; then
                for t in "$t.d"/*.cfg; do
                    [ ! -r "$t" ] || . "$t" >/dev/null ||:
                done

                while [ $# -gt 0 ]; do
                    if [ -z "${1##GRUB_*}" ]; then
                        eval "
                            if [ -n \"\${$1+x}\" ]; then
                                printf \"%s='\''%s'\''\\n\" \\
                                    '\''$1'\'' \"\${$1-}\"
                                # At least one variable defined
                                rc=0
                            fi
                        "
                    fi
                    shift
                done
            fi

            printf "rc=%d\n" "$rc"
        ' '-' "$@"
    )

    return $rc
}

# Usage: grub_config_get_val <var> [<sep>]
grub_config_get_val()
{
    local func="${FUNCNAME:-grub_config_get_val}"

    local var="${1:?missing 1st arg to ${func}() <var>}"
    local sep="${2:-|}"

    eval "
        local '$var'=''
        grub_config_get '$var' || return
        set -- \${$var-}
    "

    local ifs="$IFS"
    IFS="$sep" && printf '%c%s%c\n' "$sep" "$*" "$sep"
    IFS="$ifs"
}

## Package manager helpers

if [ -z "${pkg_is_installed__cmd-}" ]; then
    if type rpm >/dev/null 2>&1; then
        pkg_is_installed__cmd='rpm -qi'
    elif type dpkg >/dev/null 2>&1; then
        pkg_is_installed__cmd='dpkg -s'
    else
        pkg_is_installed__cmd='false'
    fi
fi

# Usage: pkg_is_installed <pkg_name>
pkg_is_installed()
{
    local func="${FUNCNAME:-pkg_is_installed}"

    local pkg_name="${1:?missing 1st arg to ${func}() <pkg_name>}"

    ${pkg_is_installed__cmd:-false} "$pkg_name" >/dev/null 2>&1 || return
}

## Shell-style file handling helpers

if by="${0##*/}" && [ -n "${by##*bash*}" ]; then
    by="by $by"
else
    by='by distro.postinst'
fi

# Usage: shell_var_replace <file> <opt> <val>
shell_var_replace()
{
    local func="${FUNCNAME:-shell_var_replace}"

    local file="${1:?missing 1st arg to ${func}() <file>}"
    local opt="${2:?missing 2d arg to ${func}() <opt>}"
    local val="${3:?missing 3rd arg to ${func}() <val>}"

    if [ -f "$file" ]; then
        local o="$opt"
        opt="${opt#\#}"

        sed -i "$file" \
            -e "s/^\s*$opt=/#commented $by#&/" \
            -e "\$a\\
\\
#replaced $by#\\
$o=\"$val\"" \
            #
    fi
}

# Usage: shell_var_extend() <file> <opt> <val>
shell_var_extend()
{
    local func="${FUNCNAME:-shell_var_extend}"

    local file="${1:?missing 1st arg to ${func}() <file>}"
    local opt="${2:?missing 2d arg to ${func}() <opt>}"
    local val="${3:?missing 3rd arg to ${func}() <val>}"

    if [ -f "$file" ]; then
        local o="$opt"
        opt="${opt#\#}"

        echo >>"$file"
        echo >>"$file" "#extended $by#"
        echo >>"$file" "$o=\"\${$opt:+\$$opt }$val\""
    fi
}

## Init manager helpers

readonly systemd_lib_unit='/lib/systemd/system'
readonly systemd_etc_unit='/etc/systemd/system'

# Usage: _systemd_validate_unit_name <unit>
_systemd_validate_unit_name()
{
    local f="${1:?missing 1st arg to _systemd_validate_unit_name() <unit>}"

    f="${f##*/}"

    # Skip invalid unit names
    [ -n "${f##*[!\[:alnum:]:_@.-]*}" ] || return
    # Skip units without name prefix, type suffix or multiple dots
    [ "$f" = "${f%%.*}.${f##*.}" ] || return
    # Skip invalid template name
    [ -n "${f##*@*}" -o "$f" = "${f%%@.*}@.${f##*@.}" ] || return
}

# Usage: systemd_unit_cleanup <unit1> <unit2> ...
systemd_unit_cleanup()
{
    # Do cleanup if enabled.
    [ -n "${systemd_do_unit_cleanup+x}" ] || return 0

    local func="${FUNCNAME:-systemd_unit_cleanup}"

    local u="${systemd_unit:-$systemd_lib_unit}"
    local p="${root-}/${u#/}"

    # Supported systemd.unit(5) directives vary from version to version.
    #
    # If local package (e.g. openvpn) being installed provides unit
    # file targeted more recent systemd(1) console is filled by systemd(1)
    # with warnings about unsupported directives.
    #
    # This helper intended to cleanup specified units to keep them only
    # with most common directives. Tested on Debian GNU/Linu 7.x (wheezy)
    # and local packages (e.g. openvpn) from 10.x (buster).

    local f
    for f in "$@"; do
        f="$p/$f"

        if [ -f "$f" ]; then
            sed -i "$f" \
                -e '/^Documentation=/           s/^/#/' \
                -e '/^Protect\(System\|Home\)=/ s/^/#/' \
                -e '/^KillMode=/                s/^/#/' \
                -e '/^Delegate=/                s/^/#/' \
                -e '/^PartOf=/                  s/^/#/' \
                -e '/^ReloadPropagatedFrom=/    s/^/#/' \
                #

            grep -q '^Type=oneshot' "$f" || continue

            sed -i "$f" \
                -e '/^ExecReload=/d' \
                #
        fi
    done
}

# Usage: systemd_unit_get <section> <attribute> <unit1> <unit2> ...
systemd_unit_get()
{
    local func="${FUNCNAME:-systemd_unit_get}"

    local section="${1:?missing 1st arg to ${func}() <section>}"
    local attribute="${2:?missing 2d arg to ${func}() <attribute>}"
    shift 2

    local u="${systemd_unit:-$systemd_lib_unit}"
    local p="${root-}/${u#/}"

    local f t=' '
    for f in "$@"; do
        _systemd_validate_unit_name "$f" || continue

        # Skip duplicates
        [ -n "${t##* $f *}" ] || continue

        t="$t$f "

        f="$p/$f"
        if [ -f "$f" ]; then
            printf -- '%s\n' "$f"
        fi
    done | xargs sed -n -e "/\\[$section\\]/,/\\[/ s/^$attribute=//p"
}

# Usage: systemd_unit_list <section> <attribute> <unit1> <unit2> ...
systemd_unit_list()
{
    local func="${FUNCNAME:-systemd_unit_list}"

    local section="${1:?missing 1st arg to ${func}() <section>}"
    local attribute="${2:?missing 2d arg to ${func}() <attribute>}"
    shift 2

    local e="${root-}/${systemd_etc_unit#/}"
    local l="${root-}/${systemd_lib_unit#/}"

    local f u=''

    local sul_tt="${sul_tt:- }"
    local et=' ' et_dir="$systemd_etc_unit"
    local lt=' ' lt_dir="$systemd_lib_unit"

    for f in "$@"; do
        f="${f##*/}"
        _systemd_validate_unit_name "$f" || continue

        # Skip duplicates
        [ -n "${sul_tt##* $f *}" ] || continue

          if [ -f "$e/$f" ]; then
            et="$et$f "
        elif [ -f "$l/$f" ]; then
            lt="$lt$f "
        else
            continue
        fi

        sul_tt="$sul_tt$f "
    done

    for f in 'et' 'lt'; do
        u=$u$(
                # skip unit name validation as it already performed
                _systemd_validate_unit_name() { :; }
                # u is in subshell is not the same as outside
                eval "
                    u="\$${f}"
                    if [ -n \"\$u\" ]; then
                        systemd_unit=\"\$${f}_dir\"
                        systemd_unit_get \"\$section\" \"\$attribute\" \$u
                    fi
                "
             )
    done

    if [ -z "$u" ]; then
        printf -- '%s\n' $sul_tt
    else
        "$func" "$section" "$attribute" $u
    fi
}

# Usage: systemd_unit_find <section> <attribute> <unit1> <unit2> ...
systemd_unit_find()
{
    local f t r="${root-}"
    for f in $(systemd_unit_list "$@"); do
        for t in \
            "$systemd_etc_unit" \
            "$systemd_lib_unit" \
            #
        do
            t="$t/$f"
            if [ -f "$r$t" ]; then
                printf -- '%s\n' "$t"
                break
            fi
        done
    done
}

# Usage: systemd_unit_enable <unit1> <unit2> ...
systemd_unit_enable()
{
    local func="${FUNCNAME:-systemd_unit_enable}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    local sue_wants='WantedBy'
    local sue_requires='RequiredBy'
    local sue_alias='Alias'

    local f t a
    for f in $(systemd_unit_find 'Install' 'Also' "$@"); do
        u="${f##*/}"
        # Skip template unit
        [ -n "${u##*@.*}" ] || continue

        for a in \
            'wants' \
            'requires' \
            '' \
            #
        do
            for t in \
                $(
                    # a is in subshell is not the same as outside
                    eval "a=\"\${sue_${a:-alias}}\""
                    systemd_unit="${f%/$u}"
                    systemd_unit_get 'Install' "$a" "$u"
                 )
            do
                if [ -n "$a" ]; then
                    t="$p/$t.$a/"
                    install -d "$t"
                    t="$t$u"
                else
                    # Alias type matches unit
                    [ "${u##*.}" = "${t##*.}" ] || continue
                    # Support Alias=foo.service.wants/bar.service
                    if [ -z "${t##*/*}" ]; then
                        t="$p/$t"
                        install -d "${t%/*}"
                    else
                        t="$p/$t"
                    fi
                fi && ln -snf "$f" "$t" || rc=$((rc + $?))
            done
        done
    done

    return $rc
}

# Usage: systemd_unit_disable <unit1> <unit2> ...
systemd_unit_disable()
{
    local func="${FUNCNAME:-systemd_unit_disable}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    local links="$(
        for l in \
            "$p"/*.wants/* \
            "$p"/*.requires/* \
            "$p"/* \
            #
        do
            _systemd_validate_unit_name "$l" || continue

            # Skip if not symlink
            [ -L "$l" ] || continue
            # Skip if unable to read symlink
            f="$(readlink "$l" 2>/dev/null)" || continue

            printf -- '%s=%s\n' "$l" "$f"
        done
    )"
    [ -n "$links" ] || return 0

    local f r="${root-}"
    for f in $(systemd_unit_find 'Install' 'Also' "$@"); do
        u="${f##*/}"
        # Skip template unit
        [ -n "${u##*@.*}" ] || continue

        for u in $links; do
            # lib -> usr/lib
            if [ "$r${u#*=}" -ef "$r$f" ]; then
                printf -- '%s\n' "${u%=*}"
            fi
        done
    done | xargs rm -f || rc=$((rc + $?))

    return $rc
}

# Usage: systemd_unit_mask <unit1> <unit2>...
systemd_unit_mask()
{
    local func="${FUNCNAME:-systemd_unit_mask}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    local f t
    for f in "$@"; do
        _systemd_validate_unit_name "$f" || continue

        t="$p/$f"
        if ! ln -snf '/dev/null' "$t"; then
            # Remove broken symlink
            rm -f "$t" && : >"$t"
        fi || rc=$((rc + $?))
    done

    return $rc
}

# Usage: systemd_unit_unmask <unit1> <unit2>...
systemd_unit_unmask()
{
    local func="${FUNCNAME:-systemd_unit_unmask}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    local f t
    for f in "$@"; do
        _systemd_validate_unit_name "$f" || continue

        t="$p/$f"
        if [ -L "$t" ]; then
            # Skip if unable to read symlink
            f="$(readlink "$t" 2>/dev/null)" || continue
            # Skip if target is not /dev/null
            [ "$f" = '/dev/null' ] || continue
        else
            # Skip unless regular empty file
            [ -f "$t" -a ! -s "$t" ] || continue
        fi
        rm -f "$t" || rc=$((rc + $?))
    done

    return $rc
}

# Usage: systemd_unit_edit [--full] <unit1> <unit2>...
systemd_unit_edit()
{
    local func="${FUNCNAME:-systemd_unit_edit}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    local full=''
    while [ $# -gt 0 ]; do
        case "$1" in
            --full)
                shift
                full='1'
                break
                ;;
            --*)
                echo >&2 "${func}: unknown option '$1'"
                return 1
                ;;
              *)
                break
                ;;
        esac
    done

    local f t args='' tt=' '
    for f in "$@"; do
        _systemd_validate_unit_name "$f" || continue

        # Skip duplicates
        [ -n "${tt##* $f *}" ] || continue

        t="$p/$f"
        if [ -z "$full" ]; then
            t="$t.d/"
            if install -d "$t"; then
                t="${t}override.conf"
            else
                rc=$((rc + $?))
                continue
            fi
        fi
        args="${args:+$args }'$t.$$'"

        tt="$tt$f "
    done

    if [ -n "$args" ]; then
        eval "set -- $args"
        if tee "$@" >/dev/null 2>&1; then
            for f in "$@"; do
                if mv -f "$f" "${f%.$$}"; then
                    :
                else
                    rc=$((rc + $?))
                    rm -f "$f" ||:
                fi
            done
        else
            rc=$((rc + $?))
        fi
    fi

    return $rc
}

# Usage: systemd_unit_cat <unit1> <unit2>...
systemd_unit_cat()
{
    local func="${FUNCNAME:-systemd_unit_cat}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local rc=0

    # Usage: _cat <file> <header>
    _cat()
    {
        if [ -r "$1" ]; then
            printf -- '# %s\n' "$2"
            cat "$1"
        fi || return
    }

    local f t r="${root-}"
    for f in $(
                 # Not parsing any attributes
                 systemd_unit_get() { :; }
                 systemd_unit_find 'all' 'all' "$@"
              )
    do
        t="$r$f"
        if _cat "$t" "$f"; then
            for t in "$p/${f##*/}.d"/*.conf; do
                f="${t#$r}"
                printf -- '\n'
                _cat "$t" "$f"
            done
        fi || rc=$((rc + $?))
    done

    unset -f _cat

    return $rc
}

# Usage: systemd_set_default <target>
systemd_set_default()
{
    local func="${FUNCNAME:-systemd_set_default}"

    local target="${1:?missing 1st arg to ${func}() <target>}"

    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local f
    for f in \
        "${u##$systemd_etc_unit}" \
        "$systemd_etc_unit" \
        "$systemd_lib_unit" \
        #
    do
        if [ -n "$f" ]; then
            if [ -n "${target##/*}" ]; then
                f="$f/$target"
            else
                f="$target"
            fi
            if [ -f "${root-}$f" ]; then
                ln -snf "$f" "$p/default.target" || return
                return 0
            fi
        fi
    done

    return 1
}

# Usage: systemd_get_default
systemd_get_default()
{
    local u="${systemd_unit:-$systemd_etc_unit}"
    local p="${root-}/${u#/}"

    local f
    for f in \
        "${u##$systemd_etc_unit}" \
        "$systemd_etc_unit" \
        "$systemd_lib_unit" \
        #
    do
        if [ -n "$f" ]; then
            f="${root-}$f/default.target"
            if [ -L "$f" ] &&
               f="$(readlink "$f" 2>/dev/null)"
            then
                printf -- '%s\n' "${f##*/}"
                return 0
            fi
        fi
    done

    return 1
}

# Usage: in_chroot ...
in_chroot()
{
    local func="${FUNCNAME:-in_chroot}"

    [ $# -gt 0 ] || return

    env -i \
        TERM="${TERM:-vt220}" \
        PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin' \
        USER='root' \
        HOME='/' \
        LANG='C' \
    ${root:+chroot "$root"} /bin/sh -c "$@" || return
}

# Usage: systemctl_helper <action> <unit1> <unit2>...
systemctl_helper()
{
    local func="${FUNCNAME:-systemctl_helper}"

    # Usage: _usage
    _usage()
    {
        local rc=$?
        local fd

        [ $rc -eq 0 ] && fd=1 || fd=2

        cat >&$fd <<EOF
Usage: $func <action> ...
Where <action> is
    enable/disable <unit1> [<unit2>...]
      Enable or Disable specific <unit> to be started and stopped
      epending on it's configuration.

    mask/unmask <unit1> [<unit2>...]
      Delete or Add <unit> to list of managed by init manager units.

    edit [--full] <unit1> [<unit2>...]
      Modify systemd(1) units with data from standard input. This
      allows overriding particular configuration items or replacing
      <unit> completely with --full option. This is systemd(1) only.

    cat <unit1> [<unit2>...]
      Display contents of systemd(1) units and overrides if any.
      This is systemd(1) only.

    set-default <systemd_target_or_runlevel_from_0_to_6>
      Set default systemd(1) target in /etc/systemd/default.target
      or SysVinit runlevel (via /etc/inittab).

    get-default
      Get current default systemd(1) target or SysVinit runlevel.
      See set-default action above for more details.

Alternative root directory can be supplied by setting root= environment
variable for this helper (e.g. root='/path/to/root' systemctl ...).

Report bugs to <serhe.popovych@gmail.com>
EOF
        return $rc
    }

    local rc=''
    if [ $# -gt 0 ]; then
        local action="$1"
        case "$action" in
            'help'|'usage')
                _usage ||:
                rc=0
                ;;
            '')
                printf >&2 -- '%s: missing first argument <action>\n' "$func"
                ! : || _usage || rc=$?
                ;;
             *)
                shift
                ;;
        esac
    else
        printf >&2 -- '%s: no arguments\n' "$func"
        ! : || _usage || rc=$?
    fi

    unset -f _usage

    [ -z "$rc" ] || return $rc

    local initd="${root-}/etc/init.d"

    # Usage: _command_not_supported
    _command_not_supported()
    {
        if [ -n "${_cns_warn_once-}" ]; then
            return 0
        else
            _cns_warn_once='1'

            : ${initman:?missing or empty variable}
            :  ${action:?missing or empty variable}

            printf >&2  -- '%s: %s unsupported command "%s"\n' \
                "$func" "$initman" "$action" \
                #

            return 124
        fi
    }
    local _cns_warn_once=''

    # Usage: sysvinit_*_enable <unit>
    sysvinit_updatercd_enable() {
        [ ! -r "$initd/$1" ] || in_chroot update-rc.d "$1" 'enable' || return
    }
    sysvinit_chkconfig_enable() {
        [ ! -r "$initd/$1" ] || in_chroot chkconfig "$1" 'on' || return
    }
    # Usage: sysvinit_*_disable <unit>
    sysvinit_updatercd_disable() {
        [ ! -r "$initd/$1" ] || in_chroot update-rc.d "$1" 'disable' || return
    }
    sysvinit_chkconfig_disable() {
        [ ! -r "$initd/$1" ] || in_chroot chkconfig "$1" 'off' || return
    }

    # Usage: sysvinit_*_mask <unit>
    sysvinit_updatercd_mask()
    {
        local rc=0

        local f
        for f in \
            "${root-}/etc"/rc?.d/[SK][0-9][0-9]"$f" \
            #
        do
            [ ! -L "$f" ] || rm -f "$f" || rc=$((rc + $?))
        done

        return $rc
    }
    sysvinit_chkconfig_mask() {
        [ ! -r "$initd/$1" ] || in_chroot chkconfig --del "$1" || return
    }
    # Usage: sysvinit_*_unmask <unit>
    sysvinit_updatercd_unmask() {
        [ ! -r "$initd/$1" ] || in_chroot update-rc.d "$1" defaults || return
    }
    sysvinit_chkconfig_unmask() {
        [ ! -r "$initd/$1" ] || in_chroot chkconfig --add "$1" || return
    }

    # Usage: sysvinit_*_edit <unit>
    sysvinit_updatercd_edit() {
        _command_not_supported || return
    }
    sysvinit_chkconfig_edit() {
        _command_not_supported || return
    }
    # Usage: sysvinit_*_cat <unit>
    sysvinit_updatercd_cat() {
        _command_not_supported || return
    }
    sysvinit_chkconfig_cat() {
        _command_not_supported || return
    }

    # Usage: sysvinit_set_default <target> [<file>]
    sysvinit_set_default()
    {
        local func="${FUNCNAME:-sysvinit_set_default}"

        local t="${1:?missing 1st arg to ${func}() <target>}"

        local f="${root-}${2:-/etc/inittab}"
        if [ -f "$f" ]; then
            local r
            case "$t" in
                  'poweroff.target')   r='0' ;;
                    'rescue.target')   r='1' ;;
                'multi-user.target')   r='3' ;;
                 'graphical.target')   r='5' ;;
                    'reboot.target')   r='6' ;;
                              [0-6])   r=$t  ;;
                                  *)   r='3' ;;
            esac

            local regex='^\([^:]\+\):[0-9]\+:\(initdefault:.*\)$'
            local nr="$(sed -n -e "/$regex/=" "$f" | sed -n -e '$ p')"
            if [ -n "$nr" ]; then
                sed -i "$f" \
                    -e "$nr s/$regex/\1:$r:\2/" \
                    #
            fi
        fi
    }

    # Usage: sysvinit_get_default [<file>]
    sysvinit_get_default()
    {
        local func="${FUNCNAME:-sysvinit_get_default}"

        local f="${root-}${1:-/etc/inittab}"
        if [ -f "$f" ]; then
            f="$(
                sed -n \
                    -e 's/^[^:]\+:\([0-9]\+\):initdefault:.*$/\1/' \
                    -e 't hold' \
                    -e 'b print' \
                    -e ': hold h' \
                    -e ': print $ {g;p}' \
                    "$f" \
                    #
            )"
            case "$f" in
                    0) f='poweroff.target'   ;;
                    1) f='rescue.target'     ;;
                2|3|4) f='multi-user.target' ;;
                    5) f='graphical.target'  ;;
                    6) f='reboot.target'     ;;
                    *) f='basic.target'      ;;
            esac
            printf -- '%s\n' "$f"
        fi
    }

    rc=0
    while :; do
        local initman
        local control

        if in_chroot command -v 'systemctl' >/dev/null 2>&1; then
            initman='systemd'
            control='unit'
        elif in_chroot command -v 'update-rc.d' >/dev/null 2>&1; then
            initman='sysvinit'
            control='updatercd'
        elif in_chroot command -v 'chkconfig' >/dev/null 2>&1; then
            initman='sysvinit'
            control='chkconfig'
        else
            printf >&2 -- '%s: unsupported init manager\n' "$func"
            rc=123
            break
        fi

        case "$action" in
            'enable'|'disable'|'mask'|'unmask'|'edit'|'cat')
                action="${initman}_${control}_${action}"
                ;;
            'get-default')
                action="${initman}_get_default"
                ;;
            'set-default')
                action="${initman}_set_default"
                ;;
            *)
                _command_not_supported || rc=$?
                break
                ;;
        esac

        case "$initman" in
            'systemd')
                "$action" "$@" || rc=$?
                ;;
            *)
                case "$action" in
                    *_get_default)
                        "$action" || rc=$((rc + $?))
                        ;;
                    *_set_default)
                        "$action" "${1-}" || rc=$((rc + $?))
                        ;;
                    *)
                        local f
                        for f in "$@"; do
                            case "${f##*.}" in
                                '')
                                    ;;
                                'service'|"$f")
                                    "$action" "${f%.service}" || rc=$((rc + $?))
                                    ;;
                            esac
                        done
                        ;;
                esac
                ;;
        esac

        break
    done

    unset -f \
        sysvinit_updatercd_enable \
        sysvinit_chkconfig_enable \
        sysvinit_updatercd_disable \
        sysvinit_chkconfig_disable \
        sysvinit_updatercd_mask \
        sysvinit_chkconfig_mask \
        sysvinit_updatercd_unmask \
        sysvinit_chkconfig_unmask \
        sysvinit_updatercd_edit \
        sysvinit_chkconfig_edit \
        sysvinit_updatercd_cat \
        sysvinit_chkconfig_cat \
        sysvinit_set_default \
        sysvinit_get_default \
        _command_not_supported \
        #

    return $rc
}

# Usage: service_enable <name>
service_enable()
{
    local func="${FUNCNAME:-service_enable}"

    local f="${1:?missing 1st arg to ${func}() <name>}"

    local rc=0

    case "${f##*.}" in
        'service'|"$f")
            f="${f%.service}"
            in_chroot "
                update-rc.d '$f' defaults &&
                update-rc.d '$f' enable
            " || rc=$?
            f="$f.service"
            ;;
    esac

    systemd_unit_cleanup "$f"
    systemd_unit_enable  "$f" || return $((rc + $?))
}

# Usage: service_disable <name>
service_disable()
{
    local func="${FUNCNAME:-service_disable}"

    local f="${1:?missing 1st arg to ${func}() <name>}"

    local rc=0

    case "${f##*.}" in
        'service'|"$f")
            f="${f%.service}"
            in_chroot "
                update-rc.d '$f' disable
            " || rc=$?
            f="$f.service"
            ;;
    esac

    systemd_unit_cleanup "$f"
    systemd_unit_disable "$f" || return $((rc + $?))
}

## Secure Shell (SSH) ~/.ssh/authorized_keys helpers

# Usage: ssh_copy_id <user1> <user2> ...
ssh_copy_id()
{
    local func="${FUNCNAME:-ssh_copy_id}"

    local u g d t ak=''

    for u in "$@"; do
        t="~$u"

        # Skip non-existent users and those without home directory
        eval "d=$t" && [ "$d" != "$t" ] || continue

        # Skip users whose home directory does not exist
        [ -d "$d" ] || continue

        # Determine effective group id for user $u
        g="$(id -g "$u")" && [ -n "$g" ] || continue

        # Make ~/.ssh if it does not already exist
        t="$d/.ssh"

        install -d -m 0700 -o "$u" -g "$g" "$t" || continue

        # Create and/or adjust ownership on authorized_keys
        t="$t/authorized_keys"

          if [ -f "$t" ]; then
            chmod 0600 "$t" && chown "$u:$g" "$t" || continue
        elif [ ! -e "$t" ]; then
            # Remove possible broken symlink
            rm -f "$t" ||:

            install -D -m 0600 -o "$u" -g "$g" /dev/null "$t" || continue
        else
            continue
        fi

        # Add to list
        ak="$ak'$t' "
    done

    eval set -- $ak

    if [ -n "${no_base64+x}" ]; then
        tee >/dev/null -a "$@"
    else
        base64 -d -i | \
        tee >/dev/null -a "$@"
    fi
}

# Usage: ssh_agent_start4bashrc() [<user1>|<file1>] [<user2>|<file1>] ...
ssh_agent_start4bashrc()
{
    local func="${FUNCNAME:-ssh_agent_start4bashrc}"

    local t f

    for f in "$@"; do
        # Skip empty arguments
        [ -n "$f" ] || continue

        # Resolve username or directory to .bashrc file
        t=''
        while :; do
              if [ -f "$f" ]; then
                t=''
                break
            elif [ -d "$f" ]; then
                f="$f/.bashrc"
            else
                # Stop on non-first attempt
                [ -z "$t" ] || break

                # User or it's home does not exist
                t="~$f" && eval "f=$t" && [ "$f" != "$t" ] || break
            fi
        done
        [ -z "$t" ] || continue

        # Skip already patched files
        t="$(
              t='# Start ssh-agent for non-X11 session'
              sed -n -e "/^$t/{p;q}" "$f"
            )" &&
        [ -z "$t" ] || continue

        # Keep it disabled by default for compatibility
        t="${f%/.bashrc}/.ssh/ssh-agent.env"
        rm -f "$t" ||:
        install -D -m 0644 /dev/null "$t" ||:

        # Patch .bashrc file at known location instead of appending
        sed -i "$f" \
            -e 'N' \
            -e '/^\s\+\. \/etc\/bashrc\s\+fi$/b patch' \
            -e '/^\s\+\. ~\/\.bash_aliases\s\+fi$/b patch' \
            -e 'P;D' \
            -e ":patch r /dev/stdin" \
        <<'_EOF'

# Start ssh-agent for non-X11 session unless ...
if [ -z "${DISPLAY-}" ]; then
    ssh_agent=''
    # Note that is is up to user to ensure that ~/.ssh isn't world writeable.
    ssh_agent_env=~/.ssh/ssh-agent.env

    while :; do
        # Socket by agent or sshd forwarded connection.
        # In latter case SSH_AGENT_PID isn't available.
        if [ -S "${SSH_AUTH_SOCK-}" ]; then
            break
        fi
        # Cleanup if not running or running but no socket.
        if [ -n "${ssh_agent##*/*}" ]; then
            unset SSH_AUTH_SOCK SSH_AGENT_PID
            break
        fi
        # Source environment.
        if [ -r "$ssh_agent_env" ]; then
            eval $(
                . "$ssh_agent_env" >/dev/null

                [ -z "${SSH_AGENT_PID-}" ] ||
                [ -z "${SSH_AGENT_PID##*\'*}" ] ||
                    echo "export SSH_AGENT_PID='$SSH_AGENT_PID'"

                [ -z "${SSH_AUTH_SOCK-}" ] ||
                [ -z "${SSH_AUTH_SOCK##*\'*}" ] ||
                    echo "export SSH_AUTH_SOCK='$SSH_AUTH_SOCK'"
            )
        fi

        if [ -n "${SSH_AGENT_PID-}" ] &&
           kill -0 "$SSH_AGENT_PID" 2>/dev/null
        then
            # ... already running
            ssh_agent='running'
        else
            # ... first attempt to start failed.
            [ -z "$ssh_agent" ] &&
            # ... disabled (e.g. with ln -sf /dev/null ~/.ssh/ssh-agent.env).
            [ ! -e "$ssh_agent_env" -o -s "$ssh_agent_env" ] &&
            # ... it exists and started successfuly.
            ssh_agent="$(command -v ssh-agent)" &&
                [ -x "$ssh_agent" ] &&
                mkdir -p "${ssh_agent_env%/*}" &&
                rm -f "$ssh_agent_env" &&
                (
                    # Make sure agent settings readable only by user
                    umask 0077 && "$ssh_agent" -s >"$ssh_agent_env"
                ) ||
            ssh_agent='not running'

            # Make sure we source environment.
            unset SSH_AUTH_SOCK
        fi
    done

    unset ssh_agent ssh_agent_env
fi
_EOF
    done
}

# Usage: config_plymouth [<theme>]
config_plymouth()
{
    local t="${1-}"

    # Themes in order of preference
    for t in \
        "$t" \
        'tribar' \
        'text' \
        'details' \
        '' \
        #
    do
        if [ -n "$t" -a -f "/usr/share/plymouth/themes/$t/$t.plymouth" ] &&
            plymouth-set-default-theme -R "$t" >/dev/null 2>&1
        then
            grub_config_add 'plymouth' 'GRUB_CMDLINE_LINUX_DEFAULT' 'splash'
            grub_update
            break
        fi
    done
}

## Debian-installer helpers

# Usage: di_chroot_cleanup <root>
di_chroot_cleanup()
{
    local func="${FUNCNAME:-di_chroot_cleanup}"

    local root="${1:?missing 1st arg to ${func}() <root>}"
    local t f

    ## Adopted from apt-setup/generators/40cdrom::chroot_cleanup_localmounts()

    rm -f "$root/usr/sbin/policy-rc.d" ||:

    # start-stop-daemon
    t="$root/sbin/start-stop-daemon" && f="$t.REAL"
    [ ! -x "$f" ] || mv -f "$f" "$t" ||:

    # initctl
    t="$root/sbin/initctl" && f="$t.REAL"
    [ ! -x "$f" ] || mv -f "$f" "$t" ||:
}

## Initial setup based on distro

eval $(
    # Source in subshell to not pollute environment

    release_file='/etc/os-release'

    if [ -f "$release_file" ] && . "$release_file" >/dev/null 2>&1; then
        distro="$ID"
        release="$VERSION_ID"
        codename="$VERSION_CODENAME"
        [ -n "$codename" ] ||
            codename="$(echo "$PRETTY_NAME" | sed -n -e 's/^.*(\(\w\+\)).*$/\1/p')"
    elif type lsb_release >/dev/null 2>&1; then
        distro="$(lsb_release -s -i)"
        release="$(lsb_release -s -r)"
        codename="$(lsb_release -s -c)"
    else
        # old or unsupported distro
        distro=''
        release=''
        codename=''
    fi

    distro="$(echo "$distro" | tr '[:upper:]' '[:lower:]')"
    [ -n "$distro" ] || exit

    release="${release%%.*}"
    [ "$release" -gt 0 ] 2>/dev/null || exit

    if [ "$distro" = 'centos' ]; then
        last_supported_release=7
    elif [ "$distro" = 'debian' ]; then
        last_supported_release=10
    else
        # unsupported distro
        exit 1
    fi

    [ $release -ge $last_supported_release ] &&
        new_distro=true || new_distro=false

    if [ "$distro" = 'debian' ]; then
        if $new_distro; then
            apt_url='http://deb.debian.org'
        else
            apt_url='http://archive.debian.org'
        fi
    else
        apt_url=''
    fi

    printf 'distro=%s release=%s codename=%s new_distro=%s apt_url=%s\n' \
        "$distro" "$release" "$codename" "$new_distro" "$apt_url"
)

[ -n "$distro" ] || exit

## Exit/return successfuly

:

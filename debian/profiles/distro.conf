#!/bin/sh

#### Bootstrap

# This is default path for build-simple-cdd(1) set by internal VARIABLES
# in python3/dist-packages/simple_cdd/variables.py.
simple_cdd_dir="${simple_cdd_dir:-$PWD}"

# Define useful helpers
if [ -z "${__included_distro_init__+x}" ]; then
    # Note that following variables should not be defined (unless
    # annotated with "local" in function) by included file(s):
    #    @path, @file

    # Usage: onoff_set <option> [<flag>] [<profile>]
    onoff_set()
    {
        local func="${FUNCNAME:-onoff_set}"

        local o="${1:?missing 1st arg to ${func}() <option>}"
        local p="${3:+$(make_shell_var "$3")}"
        [ -n "$p" ] || p="${profile_var:?no profile variable defined}"
        local d="${__include_depth__:-0}"
        local pset="__${p}_${d}_set_${o}__"
        eval "local f=\"\${2:-\${$pset:?no previous state of 'set ?$o'}}\""

        # Current option state
        local c

        case "$-" in
            *$o*) c='-' ;; # on
               *) c='+' ;; # off
        esac

        # Modify option state
        case "$f$o" in
            -?) eval "unset '$pset' && $pset='$c'" ;;
        esac

        set $f$o || set -- "$1" '' "$3"

        case "$f$o" in
            +?) eval "unset '$pset' && $pset='$c'" ;;
        esac

        # Cleanup on restore
        [ -n "$2" ] || unset "$pset"

        return 0
    }

    # Usage: set_a [<profile>]
    set_a()     { onoff_set 'a' '-' "$1"; }
    # Usage: unset_a [<profile>]
    unset_a()   { onoff_set 'a' '+' "$1"; }
    # Usage: restore_a [<profile>]
    restore_a() { onoff_set 'a'  '' "$1"; }

    # Usage: run <cmd> ...
    run()
    {
        local func="${FUNCNAME:-run}"

        local cmd="${1:?missing 1st arg to ${func}() <cmd>}"
        shift

        if [ -n "${__in_installer_env__+x}" ]; then
            :
        else
            command "$cmd" "$@"
        fi
    }

    # Deal with missing tools and/or unwanted actions in installer environment
    ln()   { run ln "$@";   }
    date() { run date "$@"; }
    gpg()  { run gpg "$@";  }

    # Usage: append <var> <val> [<noexport>] [<sep>]
    append()
    {
        local func="${FUNCNAME:-append}"

        local var="${1:?missing 1st arg to ${func}() <var>}"
        local val="${2:?missing 2d arg to ${func}() <val>}"
        local noexport="${3:-}"
        local sep="${4:-|}"

        eval "local t=\"\${$var:+\$sep\$$var}\" && t=\"\$t\$sep\""
        [ -z "${t##*$sep$val$sep*}" ] || eval "$var=\"\${$var:+\$$var\$sep}$val\""

        [ -n "$noexport" ] || eval "export '$var'"
    }

    # Usage: profile_append <var> <val> [<noexport>]
    profile_append() { append "${1-}" "${2-}" "${3-}" ','; }
    # Usage: list_append <var> <val> [<noexport>]
    list_append()    { append "${1-}" "${2-}" "${3-}" ' '; }

    # Usage: profile_description <file> <text>
    profile_description()
    {
        local func="${FUNCNAME:-profile_description}"

        local file="${1:?missing 1st arg to ${func}() <file>}"
        local text="${2:-}"

        echo 2>/dev/null \
            "$text" >"$(absolute "$file" || echo '/dev/null')" ||:
    }

    # Usage: make_shell_var <text>
    make_shell_var()
    {
        local func="${FUNCNAME:-make_shell_var}"

        local text="${1:?missing 1st arg to ${func}() <text>}"

        echo "$text" | sed -e 's/^\([^[:alpha:]_]\)/_\1/;s/\W/_/g'
    }

    # Usage: absolute <path>
    absolute()
    {
        local func="${FUNCNAME:-absolute}"

        local path="${1:?missing 1st arg to ${func}() <path>}"

        local file="${path##*/}"
        local dir="${path%$file}"
        dir="${dir:-./}"

        [ -d "$dir" ] || return

        # By default (unless -P option is given) shell's cd builtin
        # uses logical directory structure following symbolic links.
        path="$(cd "$dir" && echo "$PWD")/$file" || return

        echo "$path"
    }

    # Usaage: export_on [<profile>]
    export_on()
    {
        [ ${__include_depth__} -gt 1 ] || set_a $1
    }

    # Usage: export_off [<profile>]
    export_off()
    {
        [ ${__include_depth__} -gt 1 ] || restore_a $1
    }

    # Usage: include <file> ...
    include()
    {
        local func="${FUNCNAME:-include}"

        # Make it visible to sourced code
        local file="${1:?missing 1st arg to ${func}() <file>}"
        shift

        # Use shell's logical directory structure (follow symlinks)
        file="$(absolute "$file")" || return

        # Catch config files with missing callback
        include_deps() { exit 1; }

        # Fetch when installing from network (PXE)
        local fetch="${__in_installer_env__+x}"
        [ -z "$fetch" ] || command -v 'do_fetch' >/dev/null 2>&1 || fetch=''

        while :; do
            if [ -r "$file" ]; then
                . "$file" "$@"
                if [ -n "${__in_installer_env__+x}" ]; then
                    # Make sure we always append user supplied profiles
                    local p=",$SIMPLE_CDD_PROFILES,"
                    [ -n "${p##*,$profile,*}" ] ||
                        profile_append 'auto_profiles' "$profile"
                fi
                return 0
            fi
            [ -n "$fetch" ] || return
            local url="$SIMPLE_CDD_URL_BASE/${file##*/}"
            if do_fetch "$url" '' -q -O "$file"; then
                fetch=
            else
                return
            fi
        done
    }

    # Usage: include_skip_profile <file> ...
    include_skip_profile()
    {
        local __include_skip_profile__=1
        include "$@"
    }

    # Usage: include_skip_profile_all <file> ...
    include_skip_profile_all()
    {
        local __include_skip_profile_all__=1
        include_skip_profile "$@"
    }

    # Usage: include_begin <group> <profile> [<profile_desc>] ...
    include_begin()
    {
        # Catch empty profile names
        : "${1:?missing 1st arg to distro bootstrap code <group>}"
        : "${2:?missing 2d arg to distro bootstrap code <profile>}"

        unset_a "$2"

        # Define profile variable(s)
        profile_var="$(make_shell_var "$1")"
        profile="$2"
        profile_desc="${3+$3}"

        # Respect recursive include
        if eval "[ -n \"\${__included_${profile_var}__+x}\" ]"; then
            restore_a "$2"
            # Assert in attempt to include new profile from same group
            eval "[ \"\${__included_${profile_var}__}\" = '$2' ]" || exit
            # Signal that file already included
            return 1
        fi
        eval "__included_${profile_var}__='$2'"

        # Deferred to prevent unnecessary vars from being exported
        if [ -n "${__in_installer_env__+x}" ]; then
            # From installer environment
            simple_cdd_path=''
        else
            # From simple-cdd build wrapper
            simple_cdd_path='./profiles/groups'
        fi

        [ -n "${__included_distro_init__+x}" ] || __included_distro_init__=1
        __include_depth__=$((__include_depth__ + 1))

        # Skip profile config on request
        if [ -n "${__include_skip_profile__+x}" ]; then
            eval "__skip_profile_config_${profile_var}__='1'"
        else
            eval "unset '__skip_profile_config_${profile_var}__'"
        fi
        [ -n "${__include_skip_profile_all__+x}" ] ||
            unset '__include_skip_profile__'

        return 0
    }

    # Usage: include_end <group> <profile> [<profile_desc>] ...
    include_end()
    {
        __include_depth__=$((__include_depth__ - 1))
        restore_a "$2"

        eval "[ -z \"\${__skip_profile_config_${profile_var}__+x}\" ]"
    }

    # Usage: include_deps_wrapper <group> <profile> [<profile_desc>] ...
    include_deps_wrapper()
    {
        local pwd=''
        if [ "$simple_cdd_dir" != "$PWD" ]; then
            pwd="$PWD"
            cd "$simple_cdd_dir"
        fi

        local path="$simple_cdd_path"

        # Make sure global variable(s) preserved
        local profile_var
        local profile
        local profile_desc

        local simple_cdd_path

        # Every profile config file should define it to avoid reuse
        include_deps "$@"

        # Catch config files with missing callback
        include_deps() { exit 1; }

        if [ -n "$pwd" ]; then
            cd "$pwd"
        fi
    }

    ## Run once

    # Point scripts/init.sh symlink to distribution we building for.
    ln -sf 'debian/init.sh' "$simple_cdd_dir/scripts/init.sh"
fi # [ -z "${__included_distro_init__+x}" ]

# Usage: distro bootstrap code <group> <profile> [<profile_desc>] ...
if [ $# -gt 0 ]; then
    # Begin file include
    include_begin "$@" || return

    # Safely include dependencies
    include_deps_wrapper "$@"

    # End file include
    include_end "$@"

    return
fi # [ $# -gt 0 ]

# Usage: include_deps <group> <profile> [<profile_desc>] ...
include_deps()
{
    # Create profile description file used during the build
    profile_description "${path:+$path/$1/}./$2.description" "$3"

    # Keep profiles order, avoid duplicates and export variables
    profile_append 'profiles' "${path:+groups/$1/}$2"
    profile_append 'auto_profiles' "$2"

    # Source release specific configuration file
    include_skip_profile "${path:+$path/../}./release.conf"

    # Distribution name, version, codename and flavor unless given
    distro="${distro:-debian}"
    flavor="${flavor:-deb}"
    codename="${codename:-sid}"
    version="${version:-unstable}"
}

# Define profile and optionally it's description
set -- 'distro' 'distro' 'Distribution specific profile'

if [ -n "${__in_installer_env__+x}" ]; then
    . "$simple_cdd_dir/distro.conf" "$@"
else
    . "$simple_cdd_dir/profiles/groups/distro.conf" "$@"
fi || return 0

#### Profile configuration

## Base configuration

# Server where mirrors data stored
server="${server:-deb.debian.org}"

## Simple-CDD, debian-cd and debian-installer

# Use constomized version of debian-cd and debian-installer to make
# custom grub menus with tools/boot/sid/parse_isolinux and use
# menu.c32 instead of vesamenu.c32.
debian_cd_dir="${simple_cdd_dir}/debian-cd"
custom_installer="${simple_cdd_dir}/debian-installer/debian/tmp"

# Set distribution name.
CODENAME="${codename}"
## Set distribution architecture(s).
#ARCHES="i386 amd64"

# Make debian-cd to add recommended and suggested packages to image.
NORECOMMENDS=0
NOSUGGESTS=0

# Name ISO image and set version based on date(1)
DISKTYPE=DVD
CDNAME="debian-gnu-linux-${version}"
DISKINFO_DISTRO='Debian'
DEBVERSION="${version}"
VOLID_BASE="Debian $DEBVERSION"
DEBVER="$(date --utc '+%Y%m%d-%H%M%S')"

# Add "with firmware" to .disk/info string.
FORCE_FIRMWARE=1

# Do not add /doc, /tools and README as repository might not contain
# them. OMIT_DOC_TOOLS also ignores error when README is not available.
OMIT_DOC_TOOLS=1
OMIT_MANUAL=1
OMIT_RELEASE_NOTES=1

# Output ISO image(s) to specific directory
OUT="${simple_cdd_dir}/images"

## Prepare kernel command line parameters by build-simple-cdd

# preseed/file={simple_cdd_preseed}
simple_cdd_preseed='file=/cdrom/simple-cdd/distro.preseed'

# simple-cdd/profiles={auto_profiles} (kept for documenting)

# Additional parameters to append to kernel command line.
#KERNEL_PARAMS="$KERNEL_PARAMS nosmt"

## Mirrors

# Official mirror to get packages
debian_mirror="http://${server}/debian/"

# Official mirror to get packages with security updates
security_mirror="http://${server}/debian-security/"

# Official mirror to get package updates
updates_mirror="${debian_mirror}"

# Official mirror to get packages backported from sid
backports_mirror="${debian_mirror}"

## Explicitly enable backports and select packages based on control
## file tags using reprepro(1) filter formula.
#backports=''
#backports_filter_formula='!Package (% *-dev), !Package (% *-dbg)'

# Use reprepro(1) as wget(1) (mirror_wget.py) may fail when no
# /debian/extrafiles available on mirror. See debian bug #909299 for details at
# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=909299
mirror_tools='reprepro'

# No extra mirror files as repository might not contain them. See
# OMIT_DOC_TOOLS, OMIT_MANUAL and OMIT_RELEASE_NOTES variables
# configured for debian-cd
mirror_files=''

# It might happen that debian-archive-keyring.gpg contains expired keys
# causing reprepro(1) to fail. This happens because key expired and
# debian-archive-keyring package isn't provided.
#
# Work around that by providing explicit list of key fingerprints that
# might be used to sign various release files.
verify_release_keys="`
    # Set this to a list of absolute pathes to keyrings in global config
    keyring="${keyring:-/usr/share/keyrings/debian-archive-keyring.gpg}"

    fp=''
    for kr in $keyring; do
        [ -r "$kr" ] || continue
        gpg --no-default-keyring --keyring "$kr" --list-keys --with-colons |\
        while read line; do
            save_ifs="$IFS"; IFS=':'
            set -- $line
            IFS="$save_ifs"

            # See doc/DETAILS for field description
            case "$2" in
                e|r|n) continue ;;
            esac
            case "$12" in
                *D*) continue ;;
            esac
            case "$12" in
                *s*|*S*) ;;
                *) continue ;;
            esac

            echo -n "$5|"
        done
    done
`"
verify_release_keys="${verify_release_keys%|}"
